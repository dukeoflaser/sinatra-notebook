{
  "name": "sinatra-notebook",
  "tagline": "A small app for sharing lessons with music students.",
  "body": "As an individual who often wrestles with ducks, proceeding with any given task or idea (case in point, this blog post) can seem futile if those ducks aren't in their rows. \r\n\r\nThere are a couple lines of thought that I've picked up from [Tim Ferriss](fourhourworkweek.com/blog/) and [Scott Adams](http://blog.dilbert.com/) that have helped me overcome that tendency. I'd like to apply to these approaches to this blog post and see how it turns out.\r\n\r\n###On Experimentation\r\nIt has slowly dawned upon me that _experimentation_ is a much more rewarding and feasible approach to acting on an idea than **pre-action duck-alignment** is. In fact, I believe _agile development_, the concept of learning/navigating through rapid product testing and feedback loops is in effect, experimentation. Experimentation is a far more effective mindset for learning, for acting on ideas, and growing as a person than is perfectionist induced non-action. \r\n\r\n###On Evaluation\r\nTrack some kind of metric. Some metrics are more meaningful than others, and there is the possibility that choosing the wrong metric causes damage. But in this case, I believe any metric is better than nothing. A metric allows comparison and reveals progress or lack thereof.\r\n\r\n###On Goals\r\nGoals are great, but many times you just don't know what the best goal really is. Rather than being totally goal oriented - focused on a single outcome, system orientation helps locate that goal in times of uncertainty. \r\n\r\n\r\n###How do these apply to this blog post?\r\n* I'm treating this blog post as the documentation of an experiment. Rather than trying to come off as a being any kind of authority on the use of Sinatra or it's sidekicks, I am simply taking a look at what I learned from the process.\r\n\r\n* Tracking the number and type of things that cause me problems will allow me to see my own growth as a developer.\r\n\r\n* I do not yet know the outcome of this project or of this post. But I do know that simple documentation of successes and failures will be beneficial to my growth, and that is good enough for me.\r\n\r\n***\r\n\r\n\r\n\r\n###Where to start? Boilerplate and Workflow.\r\n####What I'm happy with.\r\nI started with a good idea of which gems I would be relying on, how to get a development database setup, and my general file requirements and dependencies. In my mind, the chain of dependencies, beginning when the app is run, looks like this:\r\n```ruby\r\ndependencies = {\r\n  :shotgun => :config,\r\n  :config => :app_controller,\r\n  :app_controller => :environment,\r\n  :environment => :gems,\r\n  :gems => :bundler\r\n}\r\n```\r\nFollowing that 'chain of command', I didn't have too much trouble getting Sinatra up and running.\r\n\r\nAs far as work flow is concerned, my tendency to get some ducks in a row paid off. Simply taking the time to create a rough mockup/flowchart gave me a good idea of what models, relationships, and views I was going to need.\r\n\r\nStarting off by creating the models and their associations seemed like a no-brainer, but effectively creating controllers and views seemed to require more mixing and matching. In the end, I sketched in the routes for each controller, and then introduced functionality to the views on an 'as-needed' basis. \r\n\r\n####What I could have done better.\r\nOnce I got my core files and directories set up, I should have saved them to an additional repository as a staring point for any future Sinatra projects. \r\n\r\nI did find [this](http://ashleygwilliams.github.io/ratpack/) boilerplate, however, which is similar to what I put together. I will probably give this a whirl next time around, although I think there is something to be said for crafting one's own set of tools if possible.\r\n\r\n###Modeling - Sinatra and High Fashion\r\n####What I'm happy with.\r\nThe way in which the models were able to interact with each other through their associations went exactly as planned and I had little trouble, if any, accessing data from any of the tables in any given situation. Part of that is due to [this experiment](http://dukeoflaser.github.io/ActiveRecordAssociations) I did with ActiveRecord's associations.\r\n\r\nCurrently, however, the models are also an area that I feel are the root of the apps biggest flaw.\r\n\r\n####What I could have done better.\r\nThe problem is that a teacher and a student can have the same user id. As they each have separate tables in the database, the first teacher to signup gets an `id` of 1 as does the first student. This causes no problems for the normal flow of the app, but what happens when the student logs in and manually types in `.../teacher/home` to the URL bar?\r\n\r\nWell, unfortunately, teacher and student specific routes depend upon the existence of a user id but are indiscriminate about the type of user.\r\n```ruby\r\nget '/teacher/home' do\r\n  unless session[:user_id].nil?\r\n    @user = Teacher.find_by_id(session[:user_id])\r\n    #...\r\nend\r\n```\r\n\r\nI think the solution to this will be simple enough, however. Upon login, a session variable containing the `user_type` needs to be set, and then checked when any teacher or student specific page is accessed.\r\n***\r\n**Edit:** I felt as though this issue did not allow the app fall under the 'Good Enough' category so I implemented the above solution and it does seem to solve the problem.\r\n***\r\n\r\nA session variable is set upon login.\r\n```ruby\r\n  if user.is_a? Teacher\r\n    session[:user_type] = 'teacher'\r\n    redirect \"/teacher/home\"\r\n  elsif user.is_a? Student\r\n    session[:user_type] = 'student'\r\n    redirect \"/student/lessons\"\r\n  end\r\n```\r\n`valid_teacher` and `valid_student` helper methods are created in corresponding controllers.\r\n```ruby\r\n  def valid_teacher\r\n    session[:user_id].nil? || session[:user_type] != 'teacher' ? false : true\r\n  end\r\n```\r\n```ruby\r\n  def valid_student\r\n    session[:user_id].nil? || session[:user_type] != 'student' ? false : true\r\n  end\r\n```\r\nEach teacher/student specific route now uses some control flow to either go ahead with the route logic or redirect back to the login page, depending on the outcome of the validation method.\r\n```ruby\r\n  get '/teacher/home' do\r\n    if valid_teacher\r\n      @user = Teacher.find_by_id(session[:user_id])\r\n      session[:student_id] = nil\r\n      erb :'/teacher/home'\r\n    else\r\n      redirect '/login'\r\n    end\r\n  end\r\n```\r\n\r\n###Multiple Controllers - Configuration.\r\n####What I'm happy with.\r\nI was tempted to dump all my routes into the main app controller, but after completing the project and looking at the files, I'm glad I didn't. In this case, having a modular structure seems like the best way to go.\r\n\r\n####What I could have done better.\r\nWhen setting the configuration block for the main App Controller, I initially assumed that those configurations would be global, and apply to my other controllers. \r\n```ruby\r\n  configure do\r\n    set :public_folder, 'public'\r\n    set :views, 'app/views'\r\n    enable :sessions\r\n    set :session_secret, 'its_a_secret'\r\n    register Sinatra::Flash\r\n  end\r\n```\r\nWhen I realized that was not the case, I experimented with the `config.ru` file to no avail. I settled on simply including the configuration block in each and every controller. That, however, seems like a bit of a code smell and I have a sneaking suspicion there is a cleaner way of achieving the same results in a less redundant manner. What that manner is though, I don't yet know.\r\n \r\nI also had an issue with '[properly](http://stackoverflow.com/questions/735073/best-way-to-require-all-files-from-a-directory-in-ruby)' requiring relative files. I could get the 'improper' method working, \r\n```ruby\r\nDir[\"./app/controllers/*.rb\"].each {|file| require file }\r\n```\r\nbut ended up with an error message when using the following 'proper' technique. \r\n```ruby\r\nDir[File.dirname(__FILE__) + './app/controllers/*.rb'].each {|file| require file }\r\n```\r\nDigging in to both statements with `pry` indicated both were returning the same array of files so it remains a mystery to me as to why the second one failed. At the end of the day I used the `require_all` gem. That tidy's things up nicely, but is likely heavy handed for requiring a minimal number of files.\r\n\r\n###Sessions vs Dynamic URLs\r\n####What I'm happy with.\r\nI'm happy with the final outcome. For the most part.\r\n\r\n####What I could have done better.\r\nI could have saved myself some time and started with the proper url structure in the first place. Instead, I started off using dynamic urls, exclusively. Even for the teacher `id` when I was actually relying on a session to provide the id.\r\nFor example, I had something like this:\r\n```ruby\r\nget '/teacher/:id/home' do\r\n  @user = Teacher.find_by_id(session[:user_id])\r\n  #...\r\nend  \r\n```\r\n\r\nThe amount of sense that makes is, to put it mildly, not a lot. At no point was I ever making use of `params[:id]`. I'm ashamed to admit how many routes I had going before I realized the pointlessness of that `:id` parameter. Let's just say, the sheer number of `<%= @user.id %>`s in my view's hyperlinks was beginning to give me claustrophobia.\r\n\r\nOnce I got rid of those unneeded parameters, particularly for both teachers and students, my routes and my view templates had some room to breath.\r\n\r\n###Keeping it DRY\r\n####What I'm happy with.\r\nI did manage to re-use several templates here and there, and I implemented a basic layout template to reduce the amount of repeat markup. Additionally, I was able to implement a number of helper methods that were used by multiple forms such as email validation and password confirmation.\r\n\r\n####What I could have done better.\r\nI believe there is a lot of room for improvement here. As far as the markup for the views go, the top and bottom navigation bars should probably have gotten their own template, and I could probably have used two distinct layout types - one for forms, one for the rest of the app. That would have reduced some of of the repetitive markup used to centre the elements on the page and would clean up the logic used for displaying flash messages.\r\n\r\nOne thing that bugs me, that has a bit of a code smell to it, is the repetition of a couple of helper methods. In fact, each controller has the exact same `invalid_email?` helper method. \r\n```ruby\r\nhelpers do\r\n  def invalid_email?(submitted_email)\r\n    valid_email = /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z]+)*\\.[a-z]+\\z/i\r\n    submitted_email.match(valid_email).nil?\r\n  end\r\nend\r\n```\r\nTo really tighten this down I would need either a module or Helper class that I could `include` or reference. I know Sinatra includes a `helpers` block for each controller, but it would be nice (and maybe it does) if it included a location for some more universal helper methods.\r\n\r\n###Final Thoughts\r\nAll in all I'm happy with this app and the fact that I was able to build it 'from scratch'. It's hardly from scratch but compared to other things I've made, it seems like it is. My confidence level has increased, my security with manipulating data has grown, and I've also discovered things that I want to figure out down the road.\r\n\r\nThis app is overly simple and doesn't solve any real problem, except perhaps, a student forgetting their super simple paper notebook. Still, I think there does remain plenty of room for expansion into something useful if time and effort were put into furthering this project.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}