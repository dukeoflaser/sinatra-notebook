{
  "name": "sinatra-notebook",
  "tagline": "A small app for sharing lessons with music students.",
  "body": "###On Experimentation\r\n\r\nI collect ducks. Usually without knowing it. I often wrestle with those ducks, trying to put them in rows. Once I get a row, I am then allowed to start. What I mean by that is this: I feel as though I need to know the most efficient methods, the most effective approaches to a task, or goal, before I start. In essence, I want to know the outcome of my actions, even before acting. That mindset, as obviously futile as it is, can often be paralyzing. It has put a stop to many of my ideas before those ideas ever started. Case in point, this blog. I have always felt as though I need to be the world's foremost expert (or close to it) on a subject in order to write about it. \r\n\r\nAs an avid reader and listener of [Tim Ferriss](fourhourworkweek.com/blog/), it has slowly dawned upon me that _experimentation_ is a much more rewarding and feasible approach to acting on an idea. I feel as though experimentation ...agile development, the concept of learning from your own actions, tracking data, is a more effective mindset for learning, for acting on ideas, and growing as a person. \r\n###On Evaluation\r\n...Track Data\r\nWith that in mind, that is the format this blog post will take. Examining issues, things that I did not/do not know, my solutions, even if they are not the best or 'right', documenting them, examining what I did right, what I can do better next time. Use this blog post as a measuring stick.\r\n\r\n\r\n###Where to start? Boilerplate and Workflow.\r\n####What I'm happy with.\r\nI had a good idea of which gems I would be relying on, how to get a development database setup, and my general file requirements and dependencies. In my mind, the chain of dependencies, beginning when the app is run, looks like this:\r\n```ruby\r\ndependencies = {\r\n  :shotgun => :config,\r\n  :config => :app_controller,\r\n  :app_controller => :environment,\r\n  :environment => :gems,\r\n  :gems => :bundler\r\n}\r\n```\r\nWith that it mind, I didn't have too much trouble getting Sinatra to fire.\r\n\r\nAs far as work flow is concerned, my tendency to get some ducks in a row paid off. Simply taking the time to create a rough mockup/flowchart gave me a good idea of what models, relationships, and views I was going to need.\r\n\r\nStarting off by creating the models and their associations seemed like a no-brainer, but effectively creating controllers and views seemed to require more mixing and matching. In the end, I sketched in the routes for each controller, and then introduced functionality to the views on an 'as-needed' basis. \r\n\r\n####What I could do better.\r\nOnce I got my core files and directories set up, I should have saved them to an additional repository as a staring point for any future Sinatra projects. \r\n\r\nI did find [this](http://ashleygwilliams.github.io/ratpack/) boilerplate, however, which is similar to what I put together. I will probably give this a whirl next time around, although I think there is something to be said for crafting one's own set of tools if possible.\r\n\r\n###Modeling - Sinatra and High Fashion\r\n####What I'm happy with.\r\nThe way in which the models were able to interact with each other through their associations went exactly as planned and I had little trouble, if any, accessing data from any of the tables in any given situation. This is the area though, that I feel is also the root of the apps biggest, current flaw.\r\n\r\n####What I could do better.\r\nThe problem, as I see it, is that a teacher and a student can have the same user id. As they each have separate tables in the database, the first teacher to signup gets an `id` of 1 as does the first student. This causes no problems for the normal flow of the app, but what happens when the student logs in, and then manually types in \".../teacher/home\" ?\r\n\r\nWell, unfortunately, this route simply depends upon the existence of that user id and is indiscriminate about the type of user.\r\n```ruby\r\nget '/teacher/home' do\r\n  unless session[:user_id].nil?\r\n    @user = Teacher.find_by_id(session[:user_id])\r\n    #...\r\nend\r\n```\r\n\r\nI think the solution to this will be simple enough, however. Upon login, a session variable containing the user type needs to be set, and then checked when any teacher or student specific page is accessed.\r\n\r\n###Multiple Controllers - Configuration.\r\n####What I'm happy with.\r\nI was tempted to dump all my routes into the main app controller, but after completing the project and looking at the files, I'm glad I didn't. In this case, having a modular structure seems like the best way to go.\r\n\r\n####What I could have done better.\r\nWhen setting the configuration block for the main App Controller, I initially assumed that those configurations would be global, and apply to my other controllers. \r\n```ruby\r\n  configure do\r\n    set :public_folder, 'public'\r\n    set :views, 'app/views'\r\n    enable :sessions\r\n    set :session_secret, 'its_a_secret'\r\n    register Sinatra::Flash\r\n  end\r\n```\r\nWhen I realized that was not the case, I experimented with my `config.ru` file to no avail. I settled on simply including the configuration block in each and every controller. That, however, seems like a bit of a code smell and I have a sneaking suspicion there is a cleaner way of achieving the same results in a less redundant way. What that way is though, I don't yet know.\r\n \r\nI also had an issue with '[properly](http://stackoverflow.com/questions/735073/best-way-to-require-all-files-from-a-directory-in-ruby)' requiring relative files. I could get the 'improper' method working, \r\n```ruby\r\nDir[\"./app/controllers/*.rb\"].each {|file| require file }\r\n```\r\nbut ended up with an error message when using the following 'proper' technique. \r\n```ruby\r\nDir[File.dirname(__FILE__) + './app/controllers/*.rb'].each {|file| require file }\r\n```\r\nDigging in to both with `pry` indicated both were returning the same array of files so it remains a mystery to me as to why the second one failed. At the end of the day I used the `require_all` gem. That tidy's things up nicely, but is likely heavy handed for requiring a minimal number of files.\r\n\r\n###Sessions vs Dynamic URLs\r\n####What I'm happy with.\r\n\r\nI'm happy with the final outcome. For the most part.\r\n\r\n####What I could have done better.\r\nI could have saved myself some time and started with the proper url structure in the first place. Instead, I started off using dynamic urls, exclusively. Even for the teacher `id` when I was actually relying on a session to provide the id.\r\nFor example, I had something like this:\r\n```ruby\r\nget '/teacher/:id/home' do\r\n  @user = Teacher.find_by_id(session[:user_id])\r\n  #...\r\nend  \r\n```\r\nThe amount of sense that makes is, to put it mildly, not a lot. I'm ashamed to admit how many routes I had going before I realized the pointlessness of that `:id` parameter. Let's just say, the sheer number of `<%= @user.id %>`s in my view's hyperlinks was beginning to give me claustrophobia.\r\n\r\nOnce I got rid of those unneeded parameters, my routes and my view templates cleaned up nicely.\r\n\r\nOnce big problem that remains with the URLs is this: What happen's \r\n\r\n###Multiple Layouts and Templates\r\n####What I'm happy with.\r\nI did manage to re-use several templates here and there, and I did implement a basic layout template to reduce the amount of repeat markup.\r\n\r\n####What I could have done better.\r\nI think there is a lot of room for improvement here. For example, the top and bottom navigation bars should probably have gotten their own template, and the container divs that centre the bulk of\r\n\r\n\r\n###The Frustration of CSS.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}